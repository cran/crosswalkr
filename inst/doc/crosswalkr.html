<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>File 1</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>Researchers often must compile master data sets
from a number of smaller data sets that are not consistent in terms of
variable names or value encodings. This can be especially true for
large administrative data sets that span multiple years and/or
departments. Other times, teams of researchers must work together to
maintain a master data set and it is important for replicability and
future collaboration that the team rely on consistent naming and
encoding conventions.</p>

<p>For example, let&#39;s say there are three flat files of student
information that need to be merged into a single large data set for
analysis.</p>

<h3>File 1</h3>

<table><thead>
<tr>
<th align="left">sid</th>
<th align="left">lname</th>
<th align="left">state</th>
<th align="left">t_score</th>
</tr>
</thead><tbody>
<tr>
<td align="left">1</td>
<td align="left">Jackson</td>
<td align="left">VA</td>
<td align="left">74</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Harrison</td>
<td align="left">KY</td>
<td align="left">86</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Nixon</td>
<td align="left">IL</td>
<td align="left">78</td>
</tr>
</tbody></table>

<h3>File 2</h3>

<table><thead>
<tr>
<th align="left">stu_id</th>
<th align="left">last_name</th>
<th align="left">st</th>
<th align="left">test_score</th>
</tr>
</thead><tbody>
<tr>
<td align="left">4</td>
<td align="left">Washington</td>
<td align="left">35</td>
<td align="left">92</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Roosevelt</td>
<td align="left">11</td>
<td align="left">67</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Taylor</td>
<td align="left">47</td>
<td align="left">68</td>
</tr>
</tbody></table>

<h3>File 3</h3>

<table><thead>
<tr>
<th align="left">s_id</th>
<th align="left">name</th>
<th align="left">sta</th>
<th align="left">score</th>
</tr>
</thead><tbody>
<tr>
<td align="left">7</td>
<td align="left">Tyler</td>
<td align="left">North Dakota</td>
<td align="left">91</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">Grant</td>
<td align="left">South Dakota</td>
<td align="left">82</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">Adams</td>
<td align="left">Illinois</td>
<td align="left">89</td>
</tr>
</tbody></table>

<p>It is clear that these files contain the same basic information, but
neither the names nor encodings for <code>state</code> | <code>st</code> | <code>sta</code> are consistent.</p>

<p>One solution is to just fix these one at a time before joining
them. For example:</p>

<pre><code class="r">library(crosswalkr)
library(dplyr)
library(labelled)
library(haven)
</code></pre>

<pre><code class="r">df1 &lt;- file_1 %&gt;%
    rename(id = sid,
           last_name = lname,
           stabbr = stat,
           score = t_score)

df2 &lt;- file_2 %&gt;%
    rename(id = stu_id,
           stabbr = st,
           score = test_score) %&gt;%
    mutate(stabbr = as.character(stabbr))

df3 &lt;- file_3 %&gt;%
    rename(id = s_id,
           stabbr = sta,
           last_name = name)

df &lt;- rbind(df1, df2, df3)
df
</code></pre>

<pre><code>##   id  last_name       stabbr score
## 1  1    Jackson           VA    74
## 2  2   Harrison           KY    86
## 3  3      Nixon           IL    78
## 4  4 Washington           35    92
## 5  5  Roosevelt           11    82
## 6  6     Taylor           47    89
## 7  7      Tyler North Dakota    91
## 8  8      Grant South Dakota    82
## 9  9      Adams     Illinois    89
</code></pre>

<p>The problem, of course, is there is a lot of room for error since the
renaming process has to be repeated for each data frame. </p>

<h3>Using a crosswalk file</h3>

<p>Instead, it makes more sense to create a crosswalk data set that
aligns old (or raw) column names with new (or clean) column names and,
if desired, labels. The <code>crosswalk</code> to join these files could be:</p>

<table><thead>
<tr>
<th align="left">clean</th>
<th align="left">label</th>
<th align="left">file_1_raw</th>
<th align="left">file_2_raw</th>
<th align="left">file_3_raw</th>
</tr>
</thead><tbody>
<tr>
<td align="left">id</td>
<td align="left">Student ID</td>
<td align="left">sid</td>
<td align="left">stu_id</td>
<td align="left">s_id</td>
</tr>
<tr>
<td align="left">last_name</td>
<td align="left">Student last name</td>
<td align="left">lname</td>
<td align="left">last_name</td>
<td align="left">name</td>
</tr>
<tr>
<td align="left">stabbr</td>
<td align="left">State abbreviation</td>
<td align="left">stat</td>
<td align="left">st</td>
<td align="left">sta</td>
</tr>
<tr>
<td align="left">score</td>
<td align="left">Test score</td>
<td align="left">t_score</td>
<td align="left">test_score</td>
<td align="left">score</td>
</tr>
</tbody></table>

<p>The crosswalk file (<code>cw_file</code>) could be:  </p>

<ol>
<li>Data frame object already in memory<br/></li>
<li>A string with path and name (<em>e.g.</em>, <code>&#39;./path/to/crosswalk.csv&#39;</code>) of a
flat file of one of the following types:<br/>

<ol>
<li>Comma separated (<code>*.csv</code>)<br/></li>
<li>Tab separated (<code>*.tsv</code>)<br/></li>
<li>Other delimited (<code>*.txt</code>) with <code>delimiter</code> option set to
delimiter string (<em>e.g.</em>, <code>delimiter = &#39;|&#39;</code>)<br/></li>
<li>Excel (<code>*.xls</code> or <code>*.xlsx</code>) with <code>sheet</code> option set to sheet
number or string name (defaulting to the first sheet)<br/></li>
<li>R data (<code>*.rdata</code>, <code>*.rda</code>, <code>*.rds</code>)<br/></li>
<li>Stata data (<code>*.dta</code>)<br/></li>
</ol></li>
</ol>

<p>If given a string to the <code>cw_file</code> argument, <code>renamefrom()</code> and
<code>encodefrom()</code> determine the type of file by its ending.</p>

<h2>Renaming</h2>

<p>To rename using the <code>renamefrom()</code> command:</p>

<pre><code class="r">df1 &lt;- renamefrom(file_1, cw_file = crosswalk, raw = file_1_raw, clean = clean, label = label)
df2 &lt;- renamefrom(file_2, cw_file = crosswalk, raw = file_2_raw, clean = clean, label = label)
df3 &lt;- renamefrom(file_3, cw_file = crosswalk, raw = file_3_raw, clean = clean, label = label)

df &lt;- rbind(df1, df2, df3)
df
</code></pre>

<pre><code>##   id  last_name       stabbr score
## 1  1    Jackson           VA    74
## 2  2   Harrison           KY    86
## 3  3      Nixon           IL    78
## 4  4 Washington           35    92
## 5  5  Roosevelt           11    82
## 6  6     Taylor           47    89
## 7  7      Tyler North Dakota    91
## 8  8      Grant South Dakota    82
## 9  9      Adams     Illinois    89
</code></pre>

<p>And check out the labels:</p>

<pre><code class="r">var_label(df)
</code></pre>

<pre><code>## $id
## [1] &quot;Student ID&quot;
## 
## $last_name
## [1] &quot;Student last name&quot;
## 
## $stabbr
## [1] &quot;State abbreviation&quot;
## 
## $score
## [1] &quot;Test score&quot;
</code></pre>

<p>As new raw data files are added to the project, they could simply be
given a new column in the crosswalk file that mapped their raw column
names to the clean versions.</p>

<h2>Encoding</h2>

<p>These same example files have inconsistent encodings for state: one
uses two-letter abbreviations, another the FIPS code, and another the
full name. Again, instead of fixing each one at a time, a separate crosswalk
for encoding these values could be used. The <code>crosswalkr</code> package
includes a state-level crosswalk, <code>stcrosswalk</code>:</p>

<pre><code class="r">data(stcrosswalk)
stcrosswalk
</code></pre>

<pre><code>## # A tibble: 51 x 7
##    stfips stabbr stname             cenreg cenregnm cendiv cendivnm        
##     &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;     &lt;int&gt; &lt;chr&gt;           
##  1      1 AL     Alabama                 3 South         6 East South Cent…
##  2      2 AK     Alaska                  4 West          9 Pacific         
##  3      4 AZ     Arizona                 4 West          8 Mountain        
##  4      5 AR     Arkansas                3 South         7 West South Cent…
##  5      6 CA     California              4 West          9 Pacific         
##  6      8 CO     Colorado                4 West          8 Mountain        
##  7      9 CT     Connecticut             1 Northea…      1 New England     
##  8     10 DE     Delaware                3 South         5 South Atlantic  
##  9     11 DC     District of Colum…      3 South         5 South Atlantic  
## 10     12 FL     Florida                 3 South         5 South Atlantic  
## # … with 41 more rows
</code></pre>

<p>The <code>encodefrom()</code> function works much like <code>renamefrom()</code>. The only
difference is that a vector of encoded values is returned that can be
added to an existing dataframe. </p>

<p><code>encodefrom()</code> returns either base R factors or labels depending on
whether the input data frame is a tibble.</p>

<h4>factor</h4>

<pre><code class="r">df1$state &lt;- encodefrom(file_1, var = stat, stcrosswalk, raw = stabbr, clean = stfips, label = stname)
df1
</code></pre>

<pre><code>##   id last_name stabbr score    state
## 1  1   Jackson     VA    74 Virginia
## 2  2  Harrison     KY    86 Kentucky
## 3  3     Nixon     IL    78 Illinois
</code></pre>

<pre><code class="r">sapply(df1, class)
</code></pre>

<pre><code>##          id   last_name      stabbr       score       state 
##   &quot;integer&quot; &quot;character&quot; &quot;character&quot;   &quot;numeric&quot;    &quot;factor&quot;
</code></pre>

<h4>labelled vector</h4>

<pre><code class="r">file_1_ &lt;- file_1 %&gt;% tbl_df()
df1$state &lt;- encodefrom(file_1_, var = stat, stcrosswalk, raw = stabbr,
                        clean = stfips, label = stname)
as_factor(df1)
</code></pre>

<pre><code>##   id last_name stabbr score    state
## 1  1   Jackson     VA    74 Virginia
## 2  2  Harrison     KY    86 Kentucky
## 3  3     Nixon     IL    78 Illinois
</code></pre>

<pre><code class="r">zap_labels(df1)
</code></pre>

<pre><code>##   id last_name stabbr score state
## 1  1   Jackson     VA    74    51
## 2  2  Harrison     KY    86    21
## 3  3     Nixon     IL    78    17
</code></pre>

<h2>Combined example: <code>dplyr</code> chain</h2>

<p>The <code>renamefrom()</code> and <code>encodefrom()</code> functions can be combined in a
<code>dplyr</code> chain.</p>

<pre><code class="r">df &lt;- rbind(file_1 %&gt;%
            tbl_df() %&gt;%
            renamefrom(., crosswalk, file_1_raw, clean, label) %&gt;%
            mutate(stabbr = encodefrom(., stabbr, stcrosswalk, stabbr, stfips, stname)),

            ## append file 2
            file_2 %&gt;%
            tbl_df() %&gt;%
            renamefrom(., crosswalk, file_2_raw, clean, label) %&gt;%
            mutate(stabbr = encodefrom(., stabbr, stcrosswalk, stfips, stfips, stname)),

            ## append file 3
            file_3 %&gt;%
            tbl_df() %&gt;%
            renamefrom(., crosswalk, file_3_raw, clean, label) %&gt;%
            mutate(stabbr = encodefrom(., stabbr, stcrosswalk, stname, stfips, stname)))

df
</code></pre>

<pre><code>## # A tibble: 9 x 4
##      id last_name                     stabbr score
##   &lt;int&gt; &lt;chr&gt;                      &lt;int+lbl&gt; &lt;dbl&gt;
## 1     1 Jackson    51 [Virginia]                74
## 2     2 Harrison   21 [Kentucky]                86
## 3     3 Nixon      17 [Illinois]                78
## 4     4 Washington 35 [New Mexico]              92
## 5     5 Roosevelt  11 [District of Columbia]    82
## 6     6 Taylor     47 [Tennessee]               89
## 7     7 Tyler      38 [North Dakota]            91
## 8     8 Grant      46 [South Dakota]            82
## 9     9 Adams      17 [Illinois]                89
</code></pre>

<pre><code class="r">as_factor(df)            
</code></pre>

<pre><code>## # A tibble: 9 x 4
##      id last_name  stabbr               score
##   &lt;int&gt; &lt;chr&gt;      &lt;fct&gt;                &lt;dbl&gt;
## 1     1 Jackson    Virginia                74
## 2     2 Harrison   Kentucky                86
## 3     3 Nixon      Illinois                78
## 4     4 Washington New Mexico              92
## 5     5 Roosevelt  District of Columbia    82
## 6     6 Taylor     Tennessee               89
## 7     7 Tyler      North Dakota            91
## 8     8 Grant      South Dakota            82
## 9     9 Adams      Illinois                89
</code></pre>

</body>

</html>
